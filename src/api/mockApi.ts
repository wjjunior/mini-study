import { Event, AssessmentStudyResponse } from "../domains/study/model/types";
import { mockStudy } from "../mockData";
import { studyCache, eventsCache, CACHE_KEYS } from "../shared/lib/api";

export async function fetchStudy(
  studyId: string,
  signal?: AbortSignal
): Promise<AssessmentStudyResponse> {
  const cacheKey = `${CACHE_KEYS.STUDY.PREFIX}:${studyId}`;
  const cached = studyCache.get(cacheKey);

  if (cached && !signal?.aborted) {
    return Promise.resolve(cached);
  }

  const latency = Math.random() * 800 + 200;

  return new Promise<AssessmentStudyResponse>((resolve, reject) => {
    if (signal?.aborted) {
      reject(new DOMException("Aborted", "AbortError"));
      return;
    }

    let settled = false;

    const cleanup = () => {
      if (signal) {
        signal.removeEventListener("abort", abortHandler);
      }
    };

    const abortHandler = () => {
      if (!settled) {
        settled = true;
        clearTimeout(timeoutId);
        cleanup();
        reject(new DOMException("Aborted", "AbortError"));
      }
    };

    const timeoutId = setTimeout(() => {
      if (signal?.aborted || settled) {
        return;
      }

      settled = true;
      cleanup();

      // Generate slightly different data per studyId to make race conditions visible
      const studyOffset = studyId.includes("002")
        ? 10
        : studyId.includes("003")
        ? 20
        : 0;

      const clone: AssessmentStudyResponse = {
        metadata: {
          ...mockStudy.metadata,
          study_id: studyId || mockStudy.metadata.study_id,
        },
        signals: {
          hr: mockStudy.signals.hr
            ? {
                ...mockStudy.signals.hr,
                values: mockStudy.signals.hr.values.map((v) => v + studyOffset),
              }
            : undefined,
          spo2: mockStudy.signals.spo2
            ? {
                ...mockStudy.signals.spo2,
                values: mockStudy.signals.spo2.values.map(
                  (v) => v - studyOffset
                ),
              }
            : undefined,
          resp: mockStudy.signals.resp
            ? {
                ...mockStudy.signals.resp,
                values: [...mockStudy.signals.resp.values],
              }
            : undefined,
          position: mockStudy.signals.position
            ? {
                ...mockStudy.signals.position,
                values: [...mockStudy.signals.position.values],
              }
            : undefined,
        },
        events: mockStudy.events.map((e: Event) => ({ ...e })),
      };

      studyCache.set(cacheKey, clone, { studyId });
      resolve(clone);
    }, latency);

    if (signal) {
      signal.addEventListener("abort", abortHandler);
    }
  });
}

export async function fetchEvents(
  studyId: string,
  signal?: AbortSignal
): Promise<Event[]> {
  const cacheKey = `${CACHE_KEYS.EVENTS.PREFIX}:${studyId}`;
  const cached = eventsCache.get(cacheKey);

  if (cached && !signal?.aborted) {
    return Promise.resolve(cached);
  }

  return new Promise<Event[]>((resolve, reject) => {
    if (signal?.aborted) {
      reject(new DOMException("Aborted", "AbortError"));
      return;
    }

    let settled = false;

    const cleanup = () => {
      if (signal) {
        signal.removeEventListener("abort", abortHandler);
      }
    };

    const abortHandler = () => {
      if (!settled) {
        settled = true;
        clearTimeout(timeoutId);
        cleanup();
        reject(new DOMException("Aborted", "AbortError"));
      }
    };

    const timeoutId = setTimeout(() => {
      if (signal?.aborted || settled) {
        return;
      }

      settled = true;
      cleanup();

      const events = mockStudy.events.map((e: Event) => ({
        ...e,
        autogenerated: Math.random() > 0.3,
      }));

      eventsCache.set(cacheKey, events, { studyId });
      resolve(events);
    }, 250);

    if (signal) {
      signal.addEventListener("abort", abortHandler);
    }
  });
}
